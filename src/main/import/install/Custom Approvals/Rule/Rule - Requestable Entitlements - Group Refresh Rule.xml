<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="Rule - Requestable Entitlements - Group Refresh Rule" type="GroupAggregationRefresh">
    <Description>- Checks the requestable entitlement configuration to decide whether or not an entitlement is requestable
    - If entitlement application is "Active Directory" then
           - set entitlement owner based on "managedBy" attribute of security group
           - set entitlement displayname based on "displayName" attribute</Description>
    <Signature returnType="Object">
        <Inputs>
            <Argument name="environment" type="Map">
                <Description>
                    Arguments passed to the aggregation task.
                </Description>
            </Argument>
            <Argument name="obj" type="ResourceObject">
                <Description>
                    A sailpoint.object.ResourceObject generated from the
                    application
                    and the ProvisioningPlan's ObjectRequest.
                </Description>
            </Argument>
            <Argument name="accountGroup" type="ManagedAttribute">
                <Description>
                    The account group being refreshed.
                </Description>
            </Argument>
            <Argument name="groupApplication" type="Application">
                <Description>
                    Application being aggregated.
                </Description>
            </Argument>
        </Inputs>
        <Returns>
            <Argument name="accountGroup" type="ManagedAttribute">
                <Description>
                    The refreshed account group object.
                </Description>
            </Argument>
        </Returns>
    </Signature>
    <Source>
<![CDATA[
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import sailpoint.api.SailPointContext;
import sailpoint.object.Application;
import sailpoint.object.Custom;
import sailpoint.object.Identity;
import sailpoint.object.ManagedAttribute;
import sailpoint.object.ResourceObject;
import sailpoint.object.Rule;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Util;

String entitlementConfigurationName = "Requestable Entitlement Configuration";
  
public void processEntitlementConfig(Custom config, ResourceObject obj, ManagedAttribute accountGroup, Application groupApplication) throws GeneralException {
  //getting information
  Map generalConfig = getGeneralConfig(config);
  Map appConfig = null;
  if(hasApplicationDefinition(config, groupApplication.getName())) {
    appConfig = getAppConfig(config, groupApplication.getName());
  }
  
  // general Configuration
  String governanceAttribute  = (String)  generalConfig.get("governanceAttribute");
  String defaultOwner         = (String)  generalConfig.get("defaultOwner");
  
  if(appConfig != null) {
    boolean configHit = false;
    
    List entConf = getAppEntitlementConfig(appConfig, groupApplication.getName());
    for(Map entry : entConf) {      
      configHit = isEntitlementMatchingConfig(obj, accountGroup, groupApplication, entry);      
      if(configHit) {
        applyChangesToEntitlement(obj, accountGroup, groupApplication, 
            entry, defaultOwner, governanceAttribute);
        break;
      }
    }
    
    if(!configHit) {
      Map appDefaultConfig = getAppDefaultConfig(appConfig, groupApplication.getName());
      if(appDefaultConfig == null) {
        String message = String.format("Config for application %s does not contain a default configuration", groupApplication.getName());
        log.error(message);
        throw new GeneralException(message);
      }
      applyChangesToEntitlement(accountGroup, appDefaultConfig, defaultOwner, governanceAttribute);
      
    }
  } else {
    applyChangesToEntitlement(accountGroup, generalConfig, "spadmin", governanceAttribute);
  }
}

private void applyChangesToEntitlement(ManagedAttribute accountGroup, Map appDefaultConfig, 
    String fallbackOwnerName, String governanceAttribute) throws GeneralException {
  String  fallbackApprover      = (String)  appDefaultConfig.get("defaultOwner");
  String  defaultApprovalLevel  = (String)  appDefaultConfig.get("defaultApprovalLevel");
  Boolean isRequestable         = Boolean.valueOf((String) appDefaultConfig.get("isRequestable"));
  
  String ownerName = fallbackApprover;
  
  if(Util.isNullOrEmpty(fallbackApprover))  {
    log.error(String.format("No defaultApprover defined. Using fallback %s", fallbackOwnerName));
    ownerName = fallbackOwnerName;
  }
  
  Identity owner = context.getObject(Identity.class, ownerName);
  if(owner == null) {
    String message = String.format("Could not retrieve identity %s. fallbackApprover was %s", ownerName, fallbackOwnerName);
    log.error(message);
    throw new GeneralException(message);
  }
  
  accountGroup.setOwner(owner);
  accountGroup.setAttribute(governanceAttribute, defaultApprovalLevel);
  accountGroup.setRequestable(isRequestable);
  log.warn("isRequestable: " + isRequestable);
}

@SuppressWarnings({ "unchecked", "rawtypes" })
private Map getAppConfig(Custom config, String applicationName) throws GeneralException {
  Map result = null;
  Map) config.get("ApplicationConfiguration");
  if(appConfig == null) {
    log.error(String.format("Custom configuration ->%s<- does not contain node %s", entitlementConfigurationName, "ApplicationConfiguration"));
    throw new GeneralException(String.format("Custom configuration ->%s<- does not contain node %s", entitlementConfigurationName, "ApplicationConfiguration"));
  }
  
  if(appConfig.containsKey(applicationName)) {
    result = appConfig.get(applicationName);
  }
     
  return result;
}

@SuppressWarnings("unchecked")
private List appConfig, String applicationName) throws GeneralException {
  List();
  if(!appConfig.containsKey("EntitlementConfiguration")) {
    String message = String.format("Configuration for appliation %s did not contain node %s", applicationName, "EntitlementConfiguration");
    log.error(message);
    throw new GeneralException(message);
  }
  result = (List) appConfig.get("EntitlementConfiguration");
  
  
  return result;
}

private Map appConfig, String applicationName) throws GeneralException {
  Map();
  if(!appConfig.containsKey("GeneralConfiguration")) {
    String message = String.format("Configuration for appliation %s did not contain node %s", applicationName, "GeneralConfiguration");
    log.error(message);
    throw new GeneralException(message);
  }
  result = (Map) appConfig.get("GeneralConfiguration");
  
  
  return result;
}

@SuppressWarnings("unchecked")
private boolean hasApplicationDefinition(Custom config, String applicationName) {
  boolean hasDefinition = false;
  Map) config.get("ApplicationConfiguration");
  hasDefinition = applicationConfiguration.containsKey(applicationName);
  
  return hasDefinition;
}

@SuppressWarnings("unchecked")
private Map getGeneralConfig(Custom config) throws GeneralException {
  Map result = null;
  Map) config.get("GeneralConfiguration");
  if(generalConfig == null) {
    String message = String.format("Custom configuration ->%s<- does not contain node %s", entitlementConfigurationName, "GeneralConfiguration");
    log.error(message);
    throw new GeneralException(message);
  }
  
  result = generalConfig;
     
  return result;
}

private void applyChangesToEntitlement(ResourceObject resourceObject, ManagedAttribute accountGroup,
    Application groupApplication, Map configuration, 
    String fallbackOwnerName, String governanceAttribute) throws GeneralException {
  
  String   appGovValue    = (String) configuration.get("governanceLevel");
  String   selectionType  = (String) configuration.get("ownerSelectionType");
  String   staticOwner    = (String) configuration.get("staticOwner");
  String   ruleName       = (String) configuration.get("ownerSelectionRuleName");
  Boolean isRequestable   = Boolean.valueOf((String) configuration.get("isRequestable"));
  
  String ownerName = null;
  
  switch(selectionType.toLowerCase()) {
    case "static" : ownerName = staticOwner; break;
    case "rule"   : ownerName = (String) handleRuleSelection(accountGroup, resourceObject, groupApplication, ruleName); break;
    default       : {
      String message = "Unknown selection type " + selectionType;
      log.error(message);
      throw new GeneralException(message);
    }
  }
  
  if(Util.isNullOrEmpty(ownerName))  {
    if(selectionType.equalsIgnoreCase("rule")) {
      log.error(String.format("Rule ->%s<- did not return an owner. That's not a good thing. Using fallback approver %s", ruleName, fallbackOwnerName));
    }
    ownerName = fallbackOwnerName;
  }
  
  Identity owner = context.getObject(Identity.class, ownerName);
  if(owner == null) {
    String message = String.format("Could not retrieve identity %s. Selection type was %s, fallbackApprover was %s", ownerName, selectionType, fallbackOwnerName);
    log.error(message);
    throw new GeneralException(message);
  }
  
  accountGroup.setOwner(owner);
  accountGroup.setAttribute(governanceAttribute, appGovValue);
  accountGroup.setRequestable(isRequestable);
  log.warn("isRequestable: " + isRequestable);
}

private boolean isEntitlementMatchingConfig(ResourceObject resourceObject, ManagedAttribute accountGroup,
    Application groupApplication, Map configuration) throws GeneralException {
  boolean configHit         = false;
  String selectionType      = (String)  configuration.get("selectionType");
  String regexAttribute     = (String)  configuration.get("selectionRegexAttribute");
  String regexValue         = (String)  configuration.get("selectionRegexValue");
  String ruleName           = (String)  configuration.get("selectionRuleName");
  
  if(Util.isNullOrEmpty(selectionType)) {
    String message = "empty selectionType";
    log.error(message);
    throw new GeneralException(message);
  }
  switch(selectionType.toLowerCase()) {
    case "regex" : configHit = handleRegexSelection(accountGroup, regexAttribute, regexValue); break;
    case "rule"  : configHit = (boolean) handleRuleSelection(accountGroup, resourceObject, groupApplication, ruleName); break;
    default      : {
      String message = "Unknown selection type " + selectionType;
      log.error(message);
      throw new GeneralException(message);
    }
  }
  return configHit;
}

private Object handleRuleSelection(ManagedAttribute accountGroup, ResourceObject obj, Application groupApplication,
    String ruleName) throws GeneralException {
  Object result = null;
  Rule rule = context.getObject(Rule.class, ruleName);
  Map();
  arguments.put("context", context);
  arguments.put("log", log);
  arguments.put("accountGroup", accountGroup);
  arguments.put("obj", obj);
  arguments.put("groupApplication", groupApplication);
  
  result = context.runRule(rule, arguments);
  
  return result;
}

private boolean handleRegexSelection(ManagedAttribute accountGroup, String regexAttribute, String regexValue) throws GeneralException {
  Boolean regexHit    = false;
  String valueToCheck = null;
  
  switch(regexAttribute.toLowerCase()) {
    case "displayname" : valueToCheck = accountGroup.getDisplayName(); break;
    case "value"       : valueToCheck = accountGroup.getValue(); break;
    case "type"        : valueToCheck = accountGroup.getType(); break;
    case "attribute"   : valueToCheck = accountGroup.getAttribute(); break;
    default            : valueToCheck = (String) accountGroup.get(regexAttribute); break;
  }
  
  if(Util.isNullOrEmpty(valueToCheck)) {
    String message = "managed attribute does not contain regexAttribute " + regexAttribute;
    log.error(message);
    throw new GeneralException(message);
  }
  
  regexHit = valueToCheck.matches(regexValue);
  
  return regexHit;
}

Custom config = context.getObject(Custom.class, entitlementConfigurationName);
processEntitlementConfig(config, obj, accountGroup, groupApplication);

return accountGroup;
 
]]>
  </Source>
</Rule>